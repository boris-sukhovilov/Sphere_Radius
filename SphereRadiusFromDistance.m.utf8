function SphereRadiusFromDistance()
    clc

    R = 1000;
    numPoints = 4;
    
    rng('shuffle');
    
%     delta = eps*R;
%     delta_m = eps*R;

    delta = .000000000000001;
    delta_m = 0;
    
    sigma  = delta/3.;
    sigma_m  = delta_m/3.;
    
    % Приближенное значение оцениваемого радиуса
    % Нужно для вычисления финального ранга измеренной матрицы квадратов расстояний
    R0 = R+0.1*R;
    
    % Диапазон азимутального угла, измеряемый в горизонтальной плоскости
    phiRange = [0 2*pi];
    % Диапазон полярного угла (угла склонения). Это угол между радиус-вектором точки и вертикальной осью
    thetaRange = [0 pi/6];
    
    % Расположение точек в недиаметральной плоскости
    % thetaRange = [pi/4 pi/4+pi/100];
    
    % Тип симплекса
    % 0 - симплекс составлен из точек, расположенных на часть сферы в диапазонах азимутального и полярного углов
    % 1 - симплекс представляет тетраэдр (tetrahedron) с попарно равными противоположными ребрами
    % 2 - симплекс представляет равнобедренную пирамиду (isosceles pyramid)
    generate_type = 1;
    
    if generate_type == 0
%         points = generateRandomPointsInSolidAngle(R, numPoints, thetaRange, phiRange, sigma_m);
        points = generateRandomPointsInSolidAngle(R, numPoints, phiRange, thetaRange, sigma_m);
    elseif generate_type == 1
        h = R*0.5;   % Расстояние от центра сферы до горизонтальных плоскостей, расположения точек
%           h = R*0.98;   % Расстояние от центра сферы до горизонтальных плоскостей, расположения точек
        h
        theta = pi / 2; % Угол между диаметральными плоскостями
        points = generate_optim_tetrahedron_points(R, h, theta, sigma_m);
    elseif generate_type == 2
        h = R*cos(thetaRange(2));
        points = generate_sphere_points_on_isosceles_pyramid(numPoints, R, h, sigma_m);
    end

    % Генерация матрицы расстояний
    [S, ~] = generateMatrixDistance(points, sigma);
%     S0
%     S

    % Tennis ball
%     R0 = 65;
%     delta = 10;
%     delta_m = 10;
%     sigma = delta/3;
%     sigma_m  = delta_m/3;
%     S = zeros(4,4);
%     S(1,2) = 41.5; S(2,1) = S(1,2);
%     S(1,3) = 59.; S(3,1) = S(1,3);
%     S(1,4) = 56.9; S(4,1) = S(1,4);
%     S(2,3) = 57.8; S(3,2) = S(2,3);
%     S(2,4) = 51.;  S(4,2) = S(2,4);
%     S(3,4) = 43.;  S(4,3) = S(3,4);
    
    [R1, sigma_R] = SphereRadius_Sukhovilov1(S, sigma, sigma_m, R0);
    fprintf('Method 1 Radius: %g\n', R1);
    fprintf('RMSE of R1: %g\n\n', sigma_R);

%     rmin0 = R1 - 3*sigma_R; 
%     rmax0 = R1 + 3*sigma_R;
%     rmin0 = max([eps, rmin0]);
%     fprintf('rmin0:%g rmax0:%g\n', rmin0, rmax0);
%     
%     
%     % Минимальный размер интервала изоляции корня 
%     d = 3*sqrt(sigma^2 + sigma_m^2)/1000;
% 
%     [R2, sigma_R, sigma_max, status] = SphereRadius_Sukhovilov2(R1, S, sigma, sigma_m, rmin0, rmax0, d);
%     if status == 1
%         for i = 1 : length(R2)
%             fprintf('Metod 2 Radius: %g\n', R2(i));
%             fprintf('RMSE of R2: %g\n', sigma_R(i));
%             fprintf('Upper bound for RMSE of R: %g\n', sigma_max(i));
%         end
%     else
%         fprintf('Metod 2 Radius not found!\n');
%     end
    
%     [R3, R_confidence_intervals] = SphereRadius_Sukhovilov3(R1, S, sigma, sigma_m);
%     fprintf('Metod 3 Radius: %g\n', R3);
%     fprintf('R3_confidence_intervals: %g\t%g\n\n', R_confidence_intervals);
%     
%     % СКО при оптимальном расположении точек на на всей поверхности сферы
%     sigma_Optim = sqrt(sigma^2/(2*numPoints^2)+sigma_m^2/numPoints);
%     fprintf('RMSE of R for optimal placement of points: %g\n\n', sigma_Optim);    
    
    % Получим ребра тетраэдра
    [a, b, c, a1, b1, c1] = getTetrahedronEdges(S);
    fprintf('a: %g\tb: %g\tc: %g\n', a,b,c);
    fprintf('a1: %g\tb1: %g\tc1: %g\n', a1,b1,c1);
    - a^2/2 - b^2/2 + c^2/2
    - a^2/2 + b^2/2 - c^2/2
      a^2/2 - b^2/2 - c^2/2
      a^2/2 + b^2/2 + c^2/2

    % Вычисление радиуса сферы, описывающей тетраэдр через определитель Кэли-Менгера
    R_Cayley_Menger = circumscribedSphereRadius_Cayley_Menger(a, b, c, a1 , b1, c1);
    fprintf('Радиус описанной сферы, вычисленный через определители Кэли-Менгера: %g\n', R_Cayley_Menger);
    
    % Вычисление квадрата радиуса сферы, описывающей тетраэдр
    % In 1752 Euler gave in effect, the following expression for V
    % In 1821 Crelle was published formula for R
    R_Grelle = circumscribedSphereRadius_Grelle(a, b, c, a1, b1, c1);
    fprintf('Радиус описанной сферы, вычисленный по формуле Grelle: %g\n', R_Grelle);

    R_Carnot = circumscribedSphereRadius_Carnot(a, b, c, a1, b1, c1);
    fprintf('Радиус описанной сферы, вычисленный по формуле Carnot: %g\n', R_Carnot);
    
end

