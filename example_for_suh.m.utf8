function example_for_suh()
    clc

    numPoints = 4;
    r = 1;
    sigma = 0.03/3;
    sigma_m = 0.1;

    R0 = r+0.1*r;

    format long

    % пример для Суховилова, что около полюсов располагать точки нежелательно
    % малые ошибки измерений вызывают большую ошибку радиуса
    % example_for_suh

    r=@(d)1/sqrt( sum(sum( inv(  [0 d(1:3); d(1) 0 d(4:5); d(2) d(4) 0 d(6);...
        d(3) d(5) d(6) 0].^2/2))));

    % исх данные расчётов
    phi=0.0988; % Угол отклонения от полюса
    % phi=0.2; % Угол отклонения от полюса
    relerr=0.01*[1,1,0,0,0,1];     % задаём относительную погрешность измерений

    disp('пример, что малые ошибки измерений вызывают большую ошибку радиуса')
    disp(['угол отклонения от полюса  ',num2str(phi)])
    disp('относительные погрешности для измерений')
    disp(relerr)

    % задаю координаты точек по предложению Суховилова
    M1=[ sin(phi); 0;         cos(phi)]; % сев полюс направо
    M2=[-sin(phi); 0;         cos(phi)];  % сев полюс налево
    M3=[0;          sin(phi); -cos(phi)]; % юж полюс от нас
    M4=[0;         -sin(phi); -cos(phi)]; % юж полюс к нам
    %  расстояния между точками с маш погрешностью
    s=zeros(1,6);
    s(1)=sqrt(     sum(   (M1-M2).^2   )         );%12
    s(2)=sqrt(     sum(   (M1-M3).^2   )         );%13
    s(3)=sqrt(     sum(   (M1-M4).^2   )         );%14
    s(4)=sqrt(     sum(   (M2-M3).^2   )         );%23
    s(5)=sqrt(     sum(   (M2-M4).^2   )         );%24
    s(6)=sqrt(     sum(   (M3-M4).^2   )         );%34
    disp('"точные" расстояния'); disp( num2str(s));

    disp(['радиус по "точным" расстояниям (анонимная функция):',num2str(r(s))])

    % S = [0   s(1) s(2) s(3);
    %     s(1) 0    s(4) s(5);
    %     s(2) s(4) 0    s(6);
    %     s(3) s(5) s(6) 0];

    % [U,S,V] = svd(S)
    % [V,D] = eig(S)


    % disp(['радиус по "точным" расстояниям   ',num2str(calculate_radius_Sukhovilov(S))])

    s=s.*(1+relerr); % измерения спогрешностью

    % s(2) = 0.5*(s(2)+s(5));
    % s(5)=s(2);
    % s(1) = 0.5*(s(1)+s(6));
    % s(6)=s(1);

    S = [0    s(1) s(2) s(3);
         s(1) 0    s(4) s(5);
         s(2) s(4) 0    s(6);
         s(3) s(5) s(6) 0];

    % tmp = (S(1,2) + S(3,4))/2;
    % % tmp = 0;
    % S(1,2) = tmp; 
    % S(3,4) = tmp; 
    % S(2,1) = tmp; 
    % S(4,3) = tmp; 
    % 
    % tmp = (S(1,4) + S(2,3))/2;
    % S(1,4) = tmp; 
    % S(2,3) = tmp; 
    % S(4,1) = tmp; 
    % S(3,2) = tmp; 
    % 
    % tmp = (S(1,3) + S(2,4))/2;
    % S(1,3) = tmp; 
    % S(2,4) = tmp; 
    % S(3,1) = tmp; 
    % S(4,2) = tmp; 

    % [U,S,V] = svd(ss)
    % [V,D] = eig(ss)

    disp('измеренные расстояния'); disp( num2str(s));

    calc_Radius(S, sigma, sigma_m, R0);

    % СКО при оптимальном расположении точек на на всей поверхности сферы
    sigma_Optim = sqrt(sigma^2/(2*numPoints^2)+sigma_m^2/numPoints);
    fprintf('RMSE of R for optimal placement of points: %g\n\n', sigma_Optim);    

end
