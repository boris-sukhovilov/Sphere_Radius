function [roots, sigma_R, sigma_max, status] = SphereRadius_Sukhovilov2(R1, S, sigma, sigma_m, rmin0, rmax0, d)

    % 2-й метод оценки радиуса c ошибками модели,
    % и ошибками измерения расстояний (расчет через собственные значения)
    % Построение матрицы S2
    C = 0.5 * S.^2;
    N = size(C,1); 
    
%     [rmin, rmax, status] = find_isolation_interval(C, rmin0, rmax0);
%     fprintf('Isolation interval are:[%g  %g]\n', rmin, rmax);
    
%     if status == 0
%         r = NaN; sigma_R = NaN; sigma_max = NaN;
%         return;
%     end
%     
%     options = optimset('Display', 'on');
%     r = fzero(@(r) r_fun(r,N,C), [rmin rmax], options);
    
    roots = find_roots(C, rmin0, rmax0, d);
    
    n_roots = length(roots);

    if n_roots == 0
%        [root, ~, exitflag,~] = fzero(@(r) r_fun(r,N,C), R1);
       [root, ~, exitflag,~] = fzero(@(r) r_fun(r,N,C), (rmin0 + rmax0)/2);
       if exitflag == 1
           roots = root;
           n_roots = 1;
       end
    end

%     n_roots = length(roots);

    if n_roots == 0
        status = 0;
        roots = NaN; sigma_R = NaN; sigma_max = NaN;
        return;
    else
        status = 1;
    end

   sigma_R = zeros(1, n_roots);
   sigma_max = zeros(1, n_roots);
   F = zeros(1, n_roots);
   for i = 1 : n_roots
       [sigma_R(i), sigma_max(i), F(i)] = rmse(roots(i), C, sigma, sigma_m);
   end
end

function f = r_fun(r,n,C)
    rr=(r.^2)*ones(n,n);
    L=eig(rr-C);   %L-собственные значения
%     di=diag(L);
    [~,j]=sort(-abs(L));  % ф-ия 'sort' сортирует в порядке возрастания
                          % j-вектор первоначальных номеров отсортированных элементов
    f=L(j(1))+L(j(2))+L(j(3))-n*r^2;
end

% function f = r_fun(r2,n,C)
%     rr=(r2)*ones(n,n);
%     L=eig(rr-C);   %L-собственные значения
% %     di=diag(L);
%     [~,j]=sort(-abs(L));  % ф-ия 'sort' сортирует в порядке возрастания
%                            % j-вектор первоначальных номеров отсортированных элементов
%     f=L(j(1))+L(j(2))+L(j(3))-n*r2;
% end


function [sigma_R, sigma_max, F] = rmse(r, C, sigma, sigma_m)

    n = size(C,1);

    % Вычисление СКО оценки радиуса
    [U,L]=eig((r .^2)*ones(n,n)-C);   % U-собственные вектора и L-собственные значения
    [~,ind]=sort(-abs(diag(L)));  % ф-ия 'sort' сортирует в порядке возрастания
                                % j-вектор первоначальных номеров отсортированных элементов
    % возмем 3 вектора, соответствующие трем наибольшим сообственным значениям
    U=U(:,[ind(1) ind(2) ind(3)]);
    
%     [U,S,V]=svds( (r .^2)*ones(n,n)-C,3 );   % U-собственные вектора и L-собственные значения
%     U,S,V
    
    summa=0;
    for i=1:3
      summa=summa+(sum(U(:,i))).^2;
    end 
    % summa

%     kov=zeros(3,3);
%     for i=1:3
%      for j=1:3
%       for k=1:n
%        for l=1:n
%         kov(i,j)=kov(i,j)+C(l,k)*(U(l,i)*U(k,i))*(U(l,j)*U(k,j));
%        end 
%       end
%      end
%     end

    kov=zeros(3,3);
    for i=1:3
     for j=1:3
        kov(i,j) =  sum(sum(C.*(U(:,i)*U(:,i)').*(U(:,j)*U(:,j)')));
     end
    end 
    
%     kov - kov1
    
    % sumkov=2*sigma^2*(sum(sum(kov))); % сумма элементов ковариационной матрицы

    % Определение СКО оценки радиуса  - sigmar
    F=n-summa;
    sigma_R=sqrt((sigma_m^2)./F+(2*sigma^2*(sum(sum(kov))))/(4*r^2*F^2));

    % Верхняя граница СКО оценки радиуса
    sigma_max=sqrt(sigma_m^2/F+18*(sigma/F)^2);

end

% function [rmin, rmax, status] = find_isolation_interval(C, rmin0, rmax0)
% 
%     N = size(C,1);
%     
%     % Начальный интервал
%     rmin = rmin0;
%     rmax = rmax0;
% 
%     % Минимальная длина подинтервала
%     epsilon = eps(rmin);
% 
%     % Начальное количество подинтервалов
%     n = 10;
% 
%     % Флаг для завершения цикла
%     found = false;
% 
%     while ~found
%         % Разделение интервала на подинтервалы
%         r = linspace(rmin, rmax, n);
% 
%         % Поиск интервала с разными знаками функции на границах
%         for i = 1:n-1
%             if r_fun(r(i),N,C) * r_fun(r(i+1),N,C) < 0
%                 rmin = r(i);
%                 rmax = r(i+1);
%                 found = true;
%                 status = 1;
%                 return;
%             end
%         end
% 
%         % Увеличение количества подинтервалов
%         n = n * 2;
% 
%         % Проверка длины подинтервала
%         if (rmax - rmin) / n < epsilon
%             fprintf('Длина подинтервала стала меньше расстояния между числами с плавающей точкой. Расчет прекращен.\n');
%             status = 0;
%             return;
%         end
%     end
% 
%     if ~found
%         fprintf('Корень не найден в заданном интервале.\n');
%         status = 0;
%     end
% end

function roots = find_roots(C, rmin0, rmax0, d)

    N = size(C,1);

    % Вычисление количества интервалов изоляции
    if d == 0
        n = 0;
    else
        n = ceil((rmax0 - rmin0) / d);
    end
    
    % Инициализация вектора для хранения корней
    roots = [];
    options = optimset('Display', 'off');

    % Цикл по интервалам изоляции
    for i = 1:n
        % Вычисление границ интервала изоляции
        x1 = rmin0 + (i-1) * d;
        x2 = rmin0 + i * d;

        % Проверка знаков функции на границах интервала
        if r_fun(x1,N,C) * r_fun(x2,N,C) <= 0
            % Вызов fzero для нахождения корня в интервале [x1, x2]
            root = fzero(@(r) r_fun(r,N,C), [x1 x2], options);
            % Сохранение найденного корня
            roots = [roots, root];
        end
    end

    % Вывод результата
    if isempty(roots)
        fprintf('Корни не найдены в заданном интервале.\n');
    else
        fprintf('Найденные корни:\n');
        disp(roots);
    end
end



